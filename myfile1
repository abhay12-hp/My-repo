ubuntu@ip-172-31-5-68:~$ sudo -i
root@ip-172-31-5-68:~# curl -fsSL https://get.docker.com -o install-docker.sh
root@ip-172-31-5-68:~# ls
install-docker.sh  snap
root@ip-172-31-5-68:~# cat install-docker.sh
#!/bin/sh
set -e
# Docker Engine for Linux installation script.
#
# This script is intended as a convenient way to configure docker's package
# repositories and to install Docker Engine, This script is not recommended
# for production environments. Before running this script, make yourself familiar
# with potential risks and limitations, and refer to the installation manual
# at https://docs.docker.com/engine/install/ for alternative installation methods.
#
# The script:
#
# - Requires `root` or `sudo` privileges to run.
# - Attempts to detect your Linux distribution and version and configure your
#   package management system for you.
# - Doesn't allow you to customize most installation parameters.
# - Installs dependencies and recommendations without asking for confirmation.
# - Installs the latest stable release (by default) of Docker CLI, Docker Engine,
#   Docker Buildx, Docker Compose, containerd, and runc. When using this script
#   to provision a machine, this may result in unexpected major version upgrades
#   of these packages. Always test upgrades in a test environment before
#   deploying to your production systems.
# - Isn't designed to upgrade an existing Docker installation. When using the
#   script to update an existing installation, dependencies may not be updated
#   to the expected version, resulting in outdated versions.
#
# Source code is available at https://github.com/docker/docker-install/
#
# Usage
# ==============================================================================
#
# To install the latest stable versions of Docker CLI, Docker Engine, and their
# dependencies:
#
# 1. download the script
#
#   $ curl -fsSL https://get.docker.com -o install-docker.sh
#
# 2. verify the script's content
#
#   $ cat install-docker.sh
#
# 3. run the script with --dry-run to verify the steps it executes
#
#   $ sh install-docker.sh --dry-run
#
# 4. run the script either as root, or using sudo to perform the installation.
#
#   $ sudo sh install-docker.sh
#
# Command-line options
# ==============================================================================
#
# --version <VERSION>
# Use the --version option to install a specific version, for example:
#
#   $ sudo sh install-docker.sh --version 23.0
#
# --channel <stable|test>
#
# Use the --channel option to install from an alternative installation channel.
# The following example installs the latest versions from the "test" channel,
# which includes pre-releases (alpha, beta, rc):
#
#   $ sudo sh install-docker.sh --channel test
#
# Alternatively, use the script at https://test.docker.com, which uses the test
# channel as default.
#
# --mirror <Aliyun|AzureChinaCloud>
#
# Use the --mirror option to install from a mirror supported by this script.
# Available mirrors are "Aliyun" (https://mirrors.aliyun.com/docker-ce), and
# "AzureChinaCloud" (https://mirror.azure.cn/docker-ce), for example:
#
#   $ sudo sh install-docker.sh --mirror AzureChinaCloud
#
# ==============================================================================


# Git commit from https://github.com/docker/docker-install when
# the script was uploaded (Should only be modified by upload job):
SCRIPT_COMMIT_SHA="4c94a56999e10efcf48c5b8e3f6afea464f9108e"

# strip "v" prefix if present
VERSION="${VERSION#v}"

# The channel to install from:
#   * stable
#   * test
DEFAULT_CHANNEL_VALUE="stable"
if [ -z "$CHANNEL" ]; then
        CHANNEL=$DEFAULT_CHANNEL_VALUE
fi

DEFAULT_DOWNLOAD_URL="https://download.docker.com"
if [ -z "$DOWNLOAD_URL" ]; then
        DOWNLOAD_URL=$DEFAULT_DOWNLOAD_URL
fi

DEFAULT_REPO_FILE="docker-ce.repo"
if [ -z "$REPO_FILE" ]; then
        REPO_FILE="$DEFAULT_REPO_FILE"
fi

mirror=''
DRY_RUN=${DRY_RUN:-}
while [ $# -gt 0 ]; do
        case "$1" in
                --channel)
                        CHANNEL="$2"
                        shift
                        ;;
                --dry-run)
                        DRY_RUN=1
                        ;;
                --mirror)
                        mirror="$2"
                        shift
                        ;;
                --version)
                        VERSION="${2#v}"
                        shift
                        ;;
                --*)
                        echo "Illegal option $1"
                        ;;
        esac
        shift $(( $# > 0 ? 1 : 0 ))
done

case "$mirror" in
        Aliyun)
                DOWNLOAD_URL="https://mirrors.aliyun.com/docker-ce"
                ;;
        AzureChinaCloud)
                DOWNLOAD_URL="https://mirror.azure.cn/docker-ce"
                ;;
        "")
                ;;
        *)
                >&2 echo "unknown mirror '$mirror': use either 'Aliyun', or 'AzureChinaCloud'."
                exit 1
                ;;
esac

case "$CHANNEL" in
        stable|test)
                ;;
        *)
                >&2 echo "unknown CHANNEL '$CHANNEL': use either stable or test."
                exit 1
                ;;
esac

command_exists() {
        command -v "$@" > /dev/null 2>&1
}

# version_gte checks if the version specified in $VERSION is at least the given
# SemVer (Maj.Minor[.Patch]), or CalVer (YY.MM) version.It returns 0 (success)
# if $VERSION is either unset (=latest) or newer or equal than the specified
# version, or returns 1 (fail) otherwise.
#
# examples:
#
# VERSION=23.0
# version_gte 23.0  // 0 (success)
# version_gte 20.10 // 0 (success)
# version_gte 19.03 // 0 (success)
# version_gte 26.1  // 1 (fail)
version_gte() {
        if [ -z "$VERSION" ]; then
                        return 0
        fi
        version_compare "$VERSION" "$1"
}

# version_compare compares two version strings (either SemVer (Major.Minor.Path),
# or CalVer (YY.MM) version strings. It returns 0 (success) if version A is newer
# or equal than version B, or 1 (fail) otherwise. Patch releases and pre-release
# (-alpha/-beta) are not taken into account
#
# examples:
#
# version_compare 23.0.0 20.10 // 0 (success)
# version_compare 23.0 20.10   // 0 (success)
# version_compare 20.10 19.03  // 0 (success)
# version_compare 20.10 20.10  // 0 (success)
# version_compare 19.03 20.10  // 1 (fail)
version_compare() (
        set +x

        yy_a="$(echo "$1" | cut -d'.' -f1)"
        yy_b="$(echo "$2" | cut -d'.' -f1)"
        if [ "$yy_a" -lt "$yy_b" ]; then
                return 1
        fi
        if [ "$yy_a" -gt "$yy_b" ]; then
                return 0
        fi
        mm_a="$(echo "$1" | cut -d'.' -f2)"
        mm_b="$(echo "$2" | cut -d'.' -f2)"

        # trim leading zeros to accommodate CalVer
        mm_a="${mm_a#0}"
        mm_b="${mm_b#0}"

        if [ "${mm_a:-0}" -lt "${mm_b:-0}" ]; then
                return 1
        fi

        return 0
)

is_dry_run() {
        if [ -z "$DRY_RUN" ]; then
                return 1
        else
                return 0
        fi
}

is_wsl() {
        case "$(uname -r)" in
        *microsoft* ) true ;; # WSL 2
        *Microsoft* ) true ;; # WSL 1
        * ) false;;
        esac
}

is_darwin() {
        case "$(uname -s)" in
        *darwin* ) true ;;
        *Darwin* ) true ;;
        * ) false;;
        esac
}

deprecation_notice() {
        distro=$1
        distro_version=$2
        echo
        printf "\033[91;1mDEPRECATION WARNING\033[0m\n"
        printf "    This Linux distribution (\033[1m%s %s\033[0m) reached end-of-life and is no longer supported by this script.\n" "$distro" "$distro_version"
        echo   "    No updates or security fixes will be released for this distribution, and users are recommended"
        echo   "    to upgrade to a currently maintained version of $distro."
        echo
        printf   "Press \033[1mCtrl+C\033[0m now to abort this script, or wait for the installation to continue."
        echo
        sleep 10
}

get_distribution() {
        lsb_dist=""
        # Every system that we officially support has /etc/os-release
        if [ -r /etc/os-release ]; then
                lsb_dist="$(. /etc/os-release && echo "$ID")"
        fi
        # Returning an empty string here should be alright since the
        # case statements don't act unless you provide an actual value
        echo "$lsb_dist"
}

echo_docker_as_nonroot() {
        if is_dry_run; then
                return
        fi
        if command_exists docker && [ -e /var/run/docker.sock ]; then
                (
                        set -x
                        $sh_c 'docker version'
                ) || true
        fi

        # intentionally mixed spaces and tabs here -- tabs are stripped by "<<-EOF", spaces are kept in the output
        echo
        echo "================================================================================"
        echo
        if version_gte "20.10"; then
                echo "To run Docker as a non-privileged user, consider setting up the"
                echo "Docker daemon in rootless mode for your user:"
                echo
                echo "    dockerd-rootless-setuptool.sh install"
                echo
                echo "Visit https://docs.docker.com/go/rootless/ to learn about rootless mode."
                echo
        fi
        echo
        echo "To run the Docker daemon as a fully privileged service, but granting non-root"
        echo "users access, refer to https://docs.docker.com/go/daemon-access/"
        echo
        echo "WARNING: Access to the remote API on a privileged Docker daemon is equivalent"
        echo "         to root access on the host. Refer to the 'Docker daemon attack surface'"
        echo "         documentation for details: https://docs.docker.com/go/attack-surface/"
        echo
        echo "================================================================================"
        echo
}

# Check if this is a forked Linux distro
check_forked() {

        # Check for lsb_release command existence, it usually exists in forked distros
        if command_exists lsb_release; then
                # Check if the `-u` option is supported
                set +e
                lsb_release -a -u > /dev/null 2>&1
                lsb_release_exit_code=$?
                set -e

                # Check if the command has exited successfully, it means we're in a forked distro
                if [ "$lsb_release_exit_code" = "0" ]; then
                        # Print info about current distro
                        cat <<-EOF
                        You're using '$lsb_dist' version '$dist_version'.
                        EOF

                        # Get the upstream release info
                        lsb_dist=$(lsb_release -a -u 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'id' | cut -d ':' -f 2 | tr -d '[:space:]')
                        dist_version=$(lsb_release -a -u 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'codename' | cut -d ':' -f 2 | tr -d '[:space:]')

                        # Print info about upstream distro
                        cat <<-EOF
                        Upstream release is '$lsb_dist' version '$dist_version'.
                        EOF
                else
                        if [ -r /etc/debian_version ] && [ "$lsb_dist" != "ubuntu" ] && [ "$lsb_dist" != "raspbian" ]; then
                                if [ "$lsb_dist" = "osmc" ]; then
                                        # OSMC runs Raspbian
                                        lsb_dist=raspbian
                                else
                                        # We're Debian and don't even know it!
                                        lsb_dist=debian
                                fi
                                dist_version="$(sed 's/\/.*//' /etc/debian_version | sed 's/\..*//')"
                                case "$dist_version" in
                                        12)
                                                dist_version="bookworm"
                                        ;;
                                        11)
                                                dist_version="bullseye"
                                        ;;
                                        10)
                                                dist_version="buster"
                                        ;;
                                        9)
                                                dist_version="stretch"
                                        ;;
                                        8)
                                                dist_version="jessie"
                                        ;;
                                esac
                        fi
                fi
        fi
}

do_install() {
        echo "# Executing docker install script, commit: $SCRIPT_COMMIT_SHA"

        if command_exists docker; then
                cat >&2 <<-'EOF'
                        Warning: the "docker" command appears to already exist on this system.

                        If you already have Docker installed, this script can cause trouble, which is
                        why we're displaying this warning and provide the opportunity to cancel the
                        installation.

                        If you installed the current Docker package using this script and are using it
                        again to update Docker, you can ignore this message, but be aware that the
                        script resets any custom changes in the deb and rpm repo configuration
                        files to match the parameters passed to the script.

                        You may press Ctrl+C now to abort this script.
                EOF
                ( set -x; sleep 20 )
        fi

        user="$(id -un 2>/dev/null || true)"

        sh_c='sh -c'
        if [ "$user" != 'root' ]; then
                if command_exists sudo; then
                        sh_c='sudo -E sh -c'
                elif command_exists su; then
                        sh_c='su -c'
                else
                        cat >&2 <<-'EOF'
                        Error: this installer needs the ability to run commands as root.
                        We are unable to find either "sudo" or "su" available to make this happen.
                        EOF
                        exit 1
                fi
        fi

        if is_dry_run; then
                sh_c="echo"
        fi

        # perform some very rudimentary platform detection
        lsb_dist=$( get_distribution )
        lsb_dist="$(echo "$lsb_dist" | tr '[:upper:]' '[:lower:]')"

        if is_wsl; then
                echo
                echo "WSL DETECTED: We recommend using Docker Desktop for Windows."
                echo "Please get Docker Desktop from https://www.docker.com/products/docker-desktop/"
                echo
                cat >&2 <<-'EOF'

                        You may press Ctrl+C now to abort this script.
                EOF
                ( set -x; sleep 20 )
        fi

        case "$lsb_dist" in

                ubuntu)
                        if command_exists lsb_release; then
                                dist_version="$(lsb_release --codename | cut -f2)"
                        fi
                        if [ -z "$dist_version" ] && [ -r /etc/lsb-release ]; then
                                dist_version="$(. /etc/lsb-release && echo "$DISTRIB_CODENAME")"
                        fi
                ;;

                debian|raspbian)
                        dist_version="$(sed 's/\/.*//' /etc/debian_version | sed 's/\..*//')"
                        case "$dist_version" in
                                12)
                                        dist_version="bookworm"
                                ;;
                                11)
                                        dist_version="bullseye"
                                ;;
                                10)
                                        dist_version="buster"
                                ;;
                                9)
                                        dist_version="stretch"
                                ;;
                                8)
                                        dist_version="jessie"
                                ;;
                        esac
                ;;

                centos|rhel)
                        if [ -z "$dist_version" ] && [ -r /etc/os-release ]; then
                                dist_version="$(. /etc/os-release && echo "$VERSION_ID")"
                        fi
                ;;

                *)
                        if command_exists lsb_release; then
                                dist_version="$(lsb_release --release | cut -f2)"
                        fi
                        if [ -z "$dist_version" ] && [ -r /etc/os-release ]; then
                                dist_version="$(. /etc/os-release && echo "$VERSION_ID")"
                        fi
                ;;

        esac

        # Check if this is a forked Linux distro
        check_forked

        # Print deprecation warnings for distro versions that recently reached EOL,
        # but may still be commonly used (especially LTS versions).
        case "$lsb_dist.$dist_version" in
                centos.8|centos.7|rhel.7)
                        deprecation_notice "$lsb_dist" "$dist_version"
                        ;;
                debian.buster|debian.stretch|debian.jessie)
                        deprecation_notice "$lsb_dist" "$dist_version"
                        ;;
                raspbian.buster|raspbian.stretch|raspbian.jessie)
                        deprecation_notice "$lsb_dist" "$dist_version"
                        ;;
                ubuntu.bionic|ubuntu.xenial|ubuntu.trusty)
                        deprecation_notice "$lsb_dist" "$dist_version"
                        ;;
                ubuntu.mantic|ubuntu.lunar|ubuntu.kinetic|ubuntu.impish|ubuntu.hirsute|ubuntu.groovy|ubuntu.eoan|ubuntu.disco|ubuntu.cosmic)
                        deprecation_notice "$lsb_dist" "$dist_version"
                        ;;
                fedora.*)
                        if [ "$dist_version" -lt 40 ]; then
                                deprecation_notice "$lsb_dist" "$dist_version"
                        fi
                        ;;
        esac

        # Run setup for each distro accordingly
        case "$lsb_dist" in
                ubuntu|debian|raspbian)
                        pre_reqs="ca-certificates curl"
                        apt_repo="deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] $DOWNLOAD_URL/linux/$lsb_dist $dist_version $CHANNEL"
                        (
                                if ! is_dry_run; then
                                        set -x
                                fi
                                $sh_c 'apt-get -qq update >/dev/null'
                                $sh_c "DEBIAN_FRONTEND=noninteractive apt-get -y -qq install $pre_reqs >/dev/null"
                                $sh_c 'install -m 0755 -d /etc/apt/keyrings'
                                $sh_c "curl -fsSL \"$DOWNLOAD_URL/linux/$lsb_dist/gpg\" -o /etc/apt/keyrings/docker.asc"
                                $sh_c "chmod a+r /etc/apt/keyrings/docker.asc"
                                $sh_c "echo \"$apt_repo\" > /etc/apt/sources.list.d/docker.list"
                                $sh_c 'apt-get -qq update >/dev/null'
                        )
                        pkg_version=""
                        if [ -n "$VERSION" ]; then
                                if is_dry_run; then
                                        echo "# WARNING: VERSION pinning is not supported in DRY_RUN"
                                else
                                        # Will work for incomplete versions IE (17.12), but may not actually grab the "latest" if in the test channel
                                        pkg_pattern="$(echo "$VERSION" | sed 's/-ce-/~ce~.*/g' | sed 's/-/.*/g')"
                                        search_command="apt-cache madison docker-ce | grep '$pkg_pattern' | head -1 | awk '{\$1=\$1};1' | cut -d' ' -f 3"
                                        pkg_version="$($sh_c "$search_command")"
                                        echo "INFO: Searching repository for VERSION '$VERSION'"
                                        echo "INFO: $search_command"
                                        if [ -z "$pkg_version" ]; then
                                                echo
                                                echo "ERROR: '$VERSION' not found amongst apt-cache madison results"
                                                echo
                                                exit 1
                                        fi
                                        if version_gte "18.09"; then
                                                        search_command="apt-cache madison docker-ce-cli | grep '$pkg_pattern' | head -1 | awk '{\$1=\$1};1' | cut -d' ' -f 3"
                                                        echo "INFO: $search_command"
                                                        cli_pkg_version="=$($sh_c "$search_command")"
                                        fi
                                        pkg_version="=$pkg_version"
                                fi
                        fi
                        (
                                pkgs="docker-ce${pkg_version%=}"
                                if version_gte "18.09"; then
                                                # older versions didn't ship the cli and containerd as separate packages
                                                pkgs="$pkgs docker-ce-cli${cli_pkg_version%=} containerd.io"
                                fi
                                if version_gte "20.10"; then
                                                pkgs="$pkgs docker-compose-plugin docker-ce-rootless-extras$pkg_version"
                                fi
                                if version_gte "23.0"; then
                                                pkgs="$pkgs docker-buildx-plugin"
                                fi
                                if ! is_dry_run; then
                                        set -x
                                fi
                                $sh_c "DEBIAN_FRONTEND=noninteractive apt-get -y -qq install $pkgs >/dev/null"
                        )
                        echo_docker_as_nonroot
                        exit 0
                        ;;
                centos|fedora|rhel)
                        repo_file_url="$DOWNLOAD_URL/linux/$lsb_dist/$REPO_FILE"
                        (
                                if ! is_dry_run; then
                                        set -x
                                fi
                                if command_exists dnf5; then
                                        $sh_c "dnf -y -q --setopt=install_weak_deps=False install dnf-plugins-core"
                                        $sh_c "dnf5 config-manager addrepo --overwrite --save-filename=docker-ce.repo --from-repofile='$repo_file_url'"

                                        if [ "$CHANNEL" != "stable" ]; then
                                                $sh_c "dnf5 config-manager setopt \"docker-ce-*.enabled=0\""
                                                $sh_c "dnf5 config-manager setopt \"docker-ce-$CHANNEL.enabled=1\""
                                        fi
                                        $sh_c "dnf makecache"
                                elif command_exists dnf; then
                                        $sh_c "dnf -y -q --setopt=install_weak_deps=False install dnf-plugins-core"
                                        $sh_c "rm -f /etc/yum.repos.d/docker-ce.repo  /etc/yum.repos.d/docker-ce-staging.repo"
                                        $sh_c "dnf config-manager --add-repo $repo_file_url"

                                        if [ "$CHANNEL" != "stable" ]; then
                                                $sh_c "dnf config-manager --set-disabled \"docker-ce-*\""
                                                $sh_c "dnf config-manager --set-enabled \"docker-ce-$CHANNEL\""
                                        fi
                                        $sh_c "dnf makecache"
                                else
                                        $sh_c "yum -y -q install yum-utils"
                                        $sh_c "rm -f /etc/yum.repos.d/docker-ce.repo  /etc/yum.repos.d/docker-ce-staging.repo"
                                        $sh_c "yum-config-manager --add-repo $repo_file_url"

                                        if [ "$CHANNEL" != "stable" ]; then
                                                $sh_c "yum-config-manager --disable \"docker-ce-*\""
                                                $sh_c "yum-config-manager --enable \"docker-ce-$CHANNEL\""
                                        fi
                                        $sh_c "yum makecache"
                                fi
                        )
                        pkg_version=""
                        if command_exists dnf; then
                                pkg_manager="dnf"
                                pkg_manager_flags="-y -q --best"
                        else
                                pkg_manager="yum"
                                pkg_manager_flags="-y -q"
                        fi
                        if [ -n "$VERSION" ]; then
                                if is_dry_run; then
                                        echo "# WARNING: VERSION pinning is not supported in DRY_RUN"
                                else
                                        if [ "$lsb_dist" = "fedora" ]; then
                                                pkg_suffix="fc$dist_version"
                                        else
                                                pkg_suffix="el"
                                        fi
                                        pkg_pattern="$(echo "$VERSION" | sed 's/-ce-/\\\\.ce.*/g' | sed 's/-/.*/g').*$pkg_suffix"
                                        search_command="$pkg_manager list --showduplicates docker-ce | grep '$pkg_pattern' | tail -1 | awk '{print \$2}'"
                                        pkg_version="$($sh_c "$search_command")"
                                        echo "INFO: Searching repository for VERSION '$VERSION'"
                                        echo "INFO: $search_command"
                                        if [ -z "$pkg_version" ]; then
                                                echo
                                                echo "ERROR: '$VERSION' not found amongst $pkg_manager list results"
                                                echo
                                                exit 1
                                        fi
                                        if version_gte "18.09"; then
                                                # older versions don't support a cli package
                                                search_command="$pkg_manager list --showduplicates docker-ce-cli | grep '$pkg_pattern' | tail -1 | awk '{print \$2}'"
                                                cli_pkg_version="$($sh_c "$search_command" | cut -d':' -f 2)"
                                        fi
                                        # Cut out the epoch and prefix with a '-'
                                        pkg_version="-$(echo "$pkg_version" | cut -d':' -f 2)"
                                fi
                        fi
                        (
                                pkgs="docker-ce$pkg_version"
                                if version_gte "18.09"; then
                                        # older versions didn't ship the cli and containerd as separate packages
                                        if [ -n "$cli_pkg_version" ]; then
                                                pkgs="$pkgs docker-ce-cli-$cli_pkg_version containerd.io"
                                        else
                                                pkgs="$pkgs docker-ce-cli containerd.io"
                                        fi
                                fi
                                if version_gte "20.10"; then
                                        pkgs="$pkgs docker-compose-plugin docker-ce-rootless-extras$pkg_version"
                                fi
                                if version_gte "23.0"; then
                                                pkgs="$pkgs docker-buildx-plugin"
                                fi
                                if ! is_dry_run; then
                                        set -x
                                fi
                                $sh_c "$pkg_manager $pkg_manager_flags install $pkgs"
                        )
                        echo_docker_as_nonroot
                        exit 0
                        ;;
                sles)
                        if [ "$(uname -m)" != "s390x" ]; then
                                echo "Packages for SLES are currently only available for s390x"
                                exit 1
                        fi
                        repo_file_url="$DOWNLOAD_URL/linux/$lsb_dist/$REPO_FILE"
                        pre_reqs="ca-certificates curl libseccomp2 awk"
                        (
                                if ! is_dry_run; then
                                        set -x
                                fi
                                $sh_c "zypper install -y $pre_reqs"
                                $sh_c "rm -f /etc/zypp/repos.d/docker-ce-*.repo"
                                $sh_c "zypper addrepo $repo_file_url"

                                opensuse_factory_url="https://download.opensuse.org/repositories/security:/SELinux/openSUSE_Factory/"
                                if ! zypper lr -d | grep -q "${opensuse_factory_url}"; then
                                        opensuse_repo="${opensuse_factory_url}security:SELinux.repo"
                                        if ! is_dry_run; then
                                                cat >&2 <<- EOF
                                                        WARNING!!
                                                        openSUSE repository ($opensuse_repo) will be enabled now.
                                                        Do you wish to continue?
                                                        You may press Ctrl+C now to abort this script.
                                                EOF
                                                ( set -x; sleep 20 )
                                        fi
                                        $sh_c "zypper addrepo $opensuse_repo"
                                fi
                                $sh_c "zypper --gpg-auto-import-keys refresh"
                                $sh_c "zypper lr -d"
                        )
                        pkg_version=""
                        if [ -n "$VERSION" ]; then
                                if is_dry_run; then
                                        echo "# WARNING: VERSION pinning is not supported in DRY_RUN"
                                else
                                        pkg_pattern="$(echo "$VERSION" | sed 's/-ce-/\\\\.ce.*/g' | sed 's/-/.*/g')"
                                        search_command="zypper search -s --match-exact 'docker-ce' | grep '$pkg_pattern' | tail -1 | awk '{print \$6}'"
                                        pkg_version="$($sh_c "$search_command")"
                                        echo "INFO: Searching repository for VERSION '$VERSION'"
                                        echo "INFO: $search_command"
                                        if [ -z "$pkg_version" ]; then
                                                echo
                                                echo "ERROR: '$VERSION' not found amongst zypper list results"
                                                echo
                                                exit 1
                                        fi
                                        search_command="zypper search -s --match-exact 'docker-ce-cli' | grep '$pkg_pattern' | tail -1 | awk '{print \$6}'"
                                        # It's okay for cli_pkg_version to be blank, since older versions don't support a cli package
                                        cli_pkg_version="$($sh_c "$search_command")"
                                        pkg_version="-$pkg_version"
                                fi
                        fi
                        (
                                pkgs="docker-ce$pkg_version"
                                if version_gte "18.09"; then
                                        if [ -n "$cli_pkg_version" ]; then
                                                # older versions didn't ship the cli and containerd as separate packages
                                                pkgs="$pkgs docker-ce-cli-$cli_pkg_version containerd.io"
                                        else
                                                pkgs="$pkgs docker-ce-cli containerd.io"
                                        fi
                                fi
                                if version_gte "20.10"; then
                                        pkgs="$pkgs docker-compose-plugin docker-ce-rootless-extras$pkg_version"
                                fi
                                if version_gte "23.0"; then
                                                pkgs="$pkgs docker-buildx-plugin"
                                fi
                                if ! is_dry_run; then
                                        set -x
                                fi
                                $sh_c "zypper -q install -y $pkgs"
                        )
                        echo_docker_as_nonroot
                        exit 0
                        ;;
                *)
                        if [ -z "$lsb_dist" ]; then
                                if is_darwin; then
                                        echo
                                        echo "ERROR: Unsupported operating system 'macOS'"
                                        echo "Please get Docker Desktop from https://www.docker.com/products/docker-desktop"
                                        echo
                                        exit 1
                                fi
                        fi
                        echo
                        echo "ERROR: Unsupported distribution '$lsb_dist'"
                        echo
                        exit 1
                        ;;
        esac
        exit 1
}

# wrapped up in a function so that we have some protection against only getting
# half the file during "curl | sh"
do_install
root@ip-172-31-5-68:~# sudo sh install-docker.sh
# Executing docker install script, commit: 4c94a56999e10efcf48c5b8e3f6afea464f9108e
+ sh -c apt-get -qq update >/dev/null
+ sh -c DEBIAN_FRONTEND=noninteractive apt-get -y -qq install ca-certificates curl >/dev/null
+ sh -c install -m 0755 -d /etc/apt/keyrings
+ sh -c curl -fsSL "https://download.docker.com/linux/ubuntu/gpg" -o /etc/apt/keyrings/docker.asc
+ sh -c chmod a+r /etc/apt/keyrings/docker.asc
+ sh -c echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu noble stable" > /etc/apt/sources.list.d/docker.list
+ sh -c apt-get -qq update >/dev/null
+ sh -c DEBIAN_FRONTEND=noninteractive apt-get -y -qq install docker-ce docker-ce-cli containerd.io docker-compose-plugin docker-ce-rootless-extras docker-buildx-plugin >/dev/null
Scanning processes...
Scanning candidates...
Scanning linux images...
+ sh -c docker version
Client: Docker Engine - Community
 Version:           28.0.1
 API version:       1.48
 Go version:        go1.23.6
 Git commit:        068a01e
 Built:             Wed Feb 26 10:41:12 2025
 OS/Arch:           linux/amd64
 Context:           default

Server: Docker Engine - Community
 Engine:
  Version:          28.0.1
  API version:      1.48 (minimum version 1.24)
  Go version:       go1.23.6
  Git commit:       bbd0a17
  Built:            Wed Feb 26 10:41:12 2025
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.7.25
  GitCommit:        bcc810d6b9066471b0b6fa75f557a15a1cbf31bb
 runc:
  Version:          1.2.4
  GitCommit:        v1.2.4-0-g6c52b3f
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0

================================================================================

To run Docker as a non-privileged user, consider setting up the
Docker daemon in rootless mode for your user:

    dockerd-rootless-setuptool.sh install

Visit https://docs.docker.com/go/rootless/ to learn about rootless mode.


To run the Docker daemon as a fully privileged service, but granting non-root
users access, refer to https://docs.docker.com/go/daemon-access/

WARNING: Access to the remote API on a privileged Docker daemon is equivalent
         to root access on the host. Refer to the 'Docker daemon attack surface'
         documentation for details: https://docs.docker.com/go/attack-surface/

================================================================================

root@ip-172-31-5-68:~# ls
install-docker.sh  snap
root@ip-172-31-5-68:~# docker -v
Docker version 28.0.1, build 068a01e
root@ip-172-31-5-68:~# service docker status
● docker.service - Docker Application Container Engine
     Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; preset: enabled)
     Active: active (running) since Wed 2025-03-19 05:19:11 UTC; 1min 15s ago
TriggeredBy: ● docker.socket
       Docs: https://docs.docker.com
   Main PID: 12825 (dockerd)
      Tasks: 8
     Memory: 45.1M (peak: 46.6M)
        CPU: 283ms
     CGroup: /system.slice/docker.service
             └─12825 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

Mar 19 05:19:10 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:10.902628421Z" level=info msg="OTEL tracing is not configured, using no-op tracer provider"
Mar 19 05:19:10 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:10.902798306Z" level=info msg="detected 127.0.0.53 nameserver, assuming systemd-resolved, so using resolv.conf: /run/systemd/resolve/resolv>
Mar 19 05:19:11 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:11.093319543Z" level=info msg="Loading containers: start."
Mar 19 05:19:11 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:11.412592584Z" level=info msg="Loading containers: done."
Mar 19 05:19:11 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:11.428355800Z" level=info msg="Docker daemon" commit=bbd0a17 containerd-snapshotter=false storage-driver=overlay2 version=28.0.1
Mar 19 05:19:11 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:11.430387821Z" level=info msg="Initializing buildkit"
Mar 19 05:19:11 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:11.481643595Z" level=info msg="Completed buildkit initialization"
Mar 19 05:19:11 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:11.493143214Z" level=info msg="Daemon has completed initialization"
Mar 19 05:19:11 ip-172-31-5-68 dockerd[12825]: time="2025-03-19T05:19:11.493281678Z" level=info msg="API listen on /run/docker.sock"
Mar 19 05:19:11 ip-172-31-5-68 systemd[1]: Started docker.service - Docker Application Container Engine.
root@ip-172-31-5-68:~# docker run --name my1stcontainer -d -p 8081:8080 jenkins/jenkins
Unable to find image 'jenkins/jenkins:latest' locally
latest: Pulling from jenkins/jenkins
155ad54a8b28: Pull complete
9cd3ad8b907a: Pull complete
2096a1b594f5: Pull complete
2b40af584007: Pull complete
ecc51e3fb14a: Pull complete
d3f4b6834408: Pull complete
fe4f59d471a4: Pull complete
bb1bd2f6d0c7: Pull complete
df69774b28d3: Pull complete
99f39e675d80: Pull complete
2793cdcd1259: Pull complete
8200837bfab5: Pull complete
Digest: sha256:03263af329cff067c038ba68937456a214fc439dcebca017d42db4606e7220a9
Status: Downloaded newer image for jenkins/jenkins:latest
6d6d5e844547926f6fe37ac01b1b2554faf55a44d8628f14af3a13815ccb1b2e
root@ip-172-31-5-68:~# Read from remote host ec2-3-108-234-179.ap-south-1.compute.amazonaws.com: Connection reset by peer
Connection to ec2-3-108-234-179.ap-south-1.compute.amazonaws.com closed.
client_loop: send disconnect: Connection reset by peer

hpabh@HP MINGW64 ~/Downloads/subbu12
$ ssh -i "ABHAYKEY.pem" ubuntu@ec2-3-108-234-179.ap-south-1.compute.amazonaws.com
Welcome to Ubuntu 24.04.2 LTS (GNU/Linux 6.8.0-1021-aws x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/pro

 System information as of Wed Mar 19 05:35:15 UTC 2025

  System load:  0.0               Processes:             118
  Usage of /:   46.8% of 6.71GB   Users logged in:       1
  Memory usage: 61%               IPv4 address for enX0: 172.31.5.68
  Swap usage:   0%


Expanded Security Maintenance for Applications is not enabled.

9 updates can be applied immediately.
9 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable

Enable ESM Apps to receive additional future security updates.
See https://ubuntu.com/esm or run: sudo pro status


*** System restart required ***
Last login: Wed Mar 19 05:13:32 2025 from 45.248.163.186
ubuntu@ip-172-31-5-68:~$ sudo -i
root@ip-172-31-5-68:~# docker images
REPOSITORY        TAG       IMAGE ID       CREATED        SIZE
jenkins/jenkins   latest    eff2362b2d14   14 hours ago   465MB
root@ip-172-31-5-68:~# docker ps
CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                                                    NAMES
6d6d5e844547   jenkins/jenkins   "/usr/bin/tini -- /u…"   16 minutes ago   Up 16 minutes   50000/tcp, 0.0.0.0:8081->8080/tcp, [::]:8081->8080/tcp   my1stcontainer
root@ip-172-31-5-68:~#
root@ip-172-31-5-68:~# ^C
root@ip-172-31-5-68:~# sudo cat /var/jenkins_home/secrets/initialAdminPassword
cat: /var/jenkins_home/secrets/initialAdminPassword: No such file or directory
root@ip-172-31-5-68:~# sudo cat/var/jenkins_home/secrets/initialAdminPassword
sudo: cat/var/jenkins_home/secrets/initialAdminPassword: command not found
root@ip-172-31-5-68:~# ls
install-docker.sh  snap
root@ip-172-31-5-68:~# docker exec -it my1stcontainer /bin/bash
jenkins@6d6d5e844547:/$ cat /var/jenkins_home/secrets/initialAdminPassword
08d0c8eb428145c283e999ed26db15c8
jenkins@6d6d5e844547:/$ ^C
jenkins@6d6d5e844547:/$ docker ps
bash: docker: command not found
jenkins@6d6d5e844547:/$ exit
exit
root@ip-172-31-5-68:~# docker ps
CONTAINER ID   IMAGE             COMMAND                  CREATED             STATUS             PORTS                                                    NAMES
6d6d5e844547   jenkins/jenkins   "/usr/bin/tini -- /u…"   About an hour ago   Up About an hour   50000/tcp, 0.0.0.0:8081->8080/tcp, [::]:8081->8080/tcp   my1stcontainer
root@ip-172-31-5-68:~# ps -a
    PID TTY          TIME CMD
  11850 pts/0    00:00:00 sudo
  11852 pts/1    00:00:00 bash
  13673 pts/2    00:00:00 sudo
  13676 pts/3    00:00:00 bash
  13759 pts/3    00:00:00 ps
root@ip-172-31-5-68:~# docker ps -a
CONTAINER ID   IMAGE             COMMAND                  CREATED             STATUS             PORTS                                                    NAMES
6d6d5e844547   jenkins/jenkins   "/usr/bin/tini -- /u…"   About an hour ago   Up About an hour   50000/tcp, 0.0.0.0:8081->8080/tcp, [::]:8081->8080/tcp   my1stcontainer
root@ip-172-31-5-68:~# docker run --name my2ndcontainerRead from remote host ec2-3-108-234-179.ap-south-1.compute.amazonaws.com: Connection reset by peer
Connection to ec2-3-108-234-179.ap-south-1.compute.amazonaws.com closed.
client_loop: send disconnect: Connection reset by peer
root@ip-172-31-5-68:~# docker run --name my2ndcontainer -d -p 8082:8080 nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
6e909acdb790: Pull complete
5eaa34f5b9c2: Pull complete
417c4bccf534: Pull complete
e7e0ca015e55: Pull complete
373fe654e984: Pull complete
97f5c0f5
